<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" lang="ko">
  <!-- 모바일 스케일 고정 -->
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta discription="2진법에 대해서 설명합니다.">
  <meta keywords="iseohyun, 진법, 실습">
  <meta author="iseohyun">

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-453XSP5W9M"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-453XSP5W9M');
  </script>

  <!-- 페이지 타이틀 -->
  <title> 2진법: 컴퓨터 일반 - iseohyun </title>
  <link rel="shortcut icon" type="image/x-icon" href="/source/icon_seohyun.svg">

  <!-- 목차 생성 -->
  <script src="/modules/script.js" defer></script>

  <!-- 수식 -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <!-- 공통스킨 -->
  <style type="text/css">
    @import url("/style.css");

    table.grid {
      border: 0px;
      padding: 0px;
      margin: 0px 10px;
      font-size: 1.3em;
    }

    table.grid tr {
      background-color: white;
    }

    table.grid tr:hover {
      background-color: white;
    }

    table.grid tr td {
      padding: 0px;
      border: 0px;
      text-align: left;
      color: #888;
    }

    input {
      font-size: 1.3em;
      text-align: right;
      padding-right: 20px;
      font-family: monospace;
    }

    mjx-math {
      font-size: 0.8em !important;
    }
  </style>
</head>

<body>
  <article>
    <div id="title"> 2진법 이해하기 </div>

    <h1>기본개념</h1>
    <h2>2진법이란</h2>
    &nbsp;0과 1만 사용하는 숫자체계를 2진수라고 합니다. 3진수는 0, 1, 2를 이용하는 숫자입니다. 10진수는 0부터 9까지 이용하는 숫자입니다. 11진수는 0~9에 한 가지 문자를 더 한
    숫자입니다. 통상적으로 11번째 문자는 a를 사용합니다. <q>표기 법</q>:
    <blockquote>
      <ul>
        <li>2진수 11 → \( 11_{(2)} \)</li>
        <li>8진수 52 → \( 52_{(8)} \)</li>
        <li>16진수 15 → \( 15_{(16)} \) </li>
      </ul>
    </blockquote>
    다음은 10진법이 다른 진법에서 어떻게 표현되는지 보여줍니다.<br>
    <table class="grid">
      <tr>
        <td>10진법 :</td>
        <td><input type="number" id="decimal" value=1 onkeyup="update(this.value)" onchange="update(this.value)"></td>
        <td style="text-align: left;">
          <button class="green" onclick="up()">Up</button>
          <button class="green" onclick="down()">Down</button>
        </td>
      </tr>
      <tr>
        <td>2진법 : </td>
        <td><input type="text" id="binary" disabled></td>
      </tr>
      <tr>
        <td>5진법 : </td>
        <td><input type="text" id="penta" disabled></td>
      </tr>
      <tr>
        <td>8진법 : </td>
        <td><input type="text" id="octa" disabled></td>
      </tr>
      <tr>
        <td>16진법 : </td>
        <td><input type="text" id="hexa" disabled></td>
      </tr>
    </table>
    &nbsp;10진법에서 9보다 큰 수를 표현하기 위해 9 다음 수는 9에서 1을 더해서 10이 됩니다. 그리고 11, 12, 13 이렇게 커지다가 19가 되면 다시 9를 0으로 바꾸고 20이 됩니다. 같은
    원리입니다.
    <blockquote>
      \( \begin{aligned} 0_{(2)} &= 0_{(10)}
      \\ 1_{(2)} &= 1_{(10)}
      \\ 10_{(2)} &= 2_{(10)}
      \\ 11_{(2)} &= 3_{(10)}
      \\ 100_{(2)} &= 4_{(10)} \end{aligned} \)
    </blockquote>
    &nbsp;2진수 100은 10진수로 4입니다. 2진수로 표현하게 되면 자릿 수가 많이 필요할 것입니다. 10진수로 999는 3자리 밖에 되지 않지만 2진수로 바꾸면 1100100 무려 7자리나 됩니다.
    <h2>중첩되다</h2>
    만약 작은 수의 진법을 바꾸는 것은 쉽습니다. 만약 10진수 100000을 2진수로 바꿀 수 있나요?<br>
    <br>
    1234는 1000+200+30+4입니다. 그리고 1000은 10진수가 3번 중첩된 모양\( 10^3 \)이지요.
    당연히 2진법 1100도 1000+100+0+0과 같습니다.<br>
    <br>
    2진법 1000은 2가 3번 중첩된 모양\( 2^3 \)입니다. 즉 2진수 1000은 10진수 8입니다.
    같은 방법으로 1100을 계산해보면 8 + 4 + 0 + 0 = 12가 됩니다. 2진수 1100은 10진수로 12입니다.<br><br>
    \( \begin{aligned} 101010_{(2)} &= 100000_{(2)} + 1000_{(2)} + 10_{(2)} \\
    &= 1 * 2^5 + 1 * 2^3 + 1 * 2^1 \\
    &= 32 + 8 + 1 = 41 \end{aligned} \)

    <h1>연산</h1>

    <h2>곱셈</h2>
    \( 123_{(10)} \)보다 \( 1230_{(10)} \)은 10배 큽니다.<br>
    \( 9000_{(10)} \)보다 \( 900_{(10)} \)은 10배 작습니다.<br>
    <br>

    우리는 <q>10진수에서 10배 할 때마다 숫자의 맨 오른쪽에 0 하나를 붙입니다.</q><br>
    \( \frac{1}{10} \)배 할 때는 맨 오른쪽의 0을 하나 지웁니다.<br>
    <br>

    2진수도 마찬가지입니다. <q>2진수에서 2배 할 때는 오른쪽에 0 하나를 붙입니다.</q><br>
    2진수에서 \( 11100_{(2)} \)은 \( 1110_{(2)} \)보다 2배 큽니다.<br>
    \( 1110_{(2)} \)보다 2배 작은 수는 \( 111_{(2)} \)이 됩니다.<br>
    <br>
    조금 복잡한 곱셈은 어떻게 하나요? 10배 100배가 아닌 20배 25배는 어떻게 하나요?<br>
    <br>

    예를들어 23 × 15를 생각해봅시다. 23 × 10 + 23 × 5 와 같습니다.
    <blockquote style="font-family: monospace;">
      <pre>       2 3
  x    1 5
  ---------
     1 1 5
  +  2 3
  ---------
     3 4 5</pre>
    </blockquote>

    &nbsp;2진수도 마찬가지입니다. \( 110_{(2)} \times 101_{(2)} = 110_{(2)} \times 100_{(2)} + 110_{(2)} \times 1_{(2)} \)과 같습니다.
    그러므로 답은 \( 11000_{(2)} + 110_{(2)} = 11110_{(2)} \)입니다.
    <blockquote style="font-family: monospace;">
      <pre>           1 1 0   --> 6
  x        1 0 1   --> 5
  --------------
           1 1 0
  +    1 1 0
  --------------
       1 1 1 1 0   --> 30</pre>
    </blockquote>
    결과는 \( 110_{(2)} = 6_{(10)}, 101_{(2)} = 5_{(10)} \) 이므로 \( 11110_{(2)} = 30_{(10)} \)이 나옵니다. 그리고 이것은 우연이 아닙니다.
    <blockquote>
      <ol>
        <li> \( 1110_{(2)} \times 101_{(2)} = ?_{(2)} \)</li>
        <li> \( 12_{(6)} \times 55_{(6)} = ?_{(6)} \)</li>
        <li>(※6진법 구구단 5단을 만들어 보세요.) 5 × 1 = 5, 5 × 2 = 14, 5 × 3 = 30 ... </li>
      </ol>
    </blockquote>
    <h2>소수점 표현</h2>
    &nbsp;소수점표현 역시 10진법과 동일합니다.<br>
    <br>
    \( 0.123 = 0.1 + 0.02 + 0.003 \) 입니다.<br>
    \( 1 \times 10^{-1} + 2 \times 10^{-2} + 2 \times 10^{-3} \)입니다.<br>
    <br>
    &nbsp;마찬가지로 \( 0.101_{(2)} = 0.1_{(2)} + 0.001_{(2)} \)로 표현이 가능합니다.

    \( 0.1_{(2)} = 1 \times 2^{-1} \)이므로 \( \frac{1}{2} =0.5 \)가 됩니다.<br>
    \( 0.01_{(2)} = 1 \times 2^{-2} \)이므로 \( \frac{1}{4} =0.25 \)가 됩니다.<br>
    \( 0.001_{(2)} = 1 \times 2^{-3} \)이므로 \( \frac{1}{8} =0.125 \)가 됩니다.<br>
    <blockquote>
      <ul>
        <li> \( \begin{aligned} 11.111_{(2)} \text{ }&= \text{ }?_{(10)} \\
          3.14_{(5)} &= \text{ }?_{(10)} \end{aligned} \)</li>
      </ul>
    </blockquote>
    <h3>컴퓨터가 저장하는 방식</h3>
    &nbsp;지수표기법은 1234000와 0.1234를 각각 \( 1.234 \times 10^6 \)과 \( 1.234 \times 10^{-1} \)으로 표현합니다. 컴퓨터 역시 \(
    10110000_{(2)}
    = 1.011_{(2)}^{111_{(2)}} \)로 \( 0.00001011_{(2)} = 1.011_{(2)}^{101_{(2)}} \)로 저장합니다.
    아패 예시는 자바프로그램으로 각각의 값을 출력해 본 것입니다. <a
      href="https://github.com/iseohyun/java-tutorial/blob/master/BasicCode/Syntax/a_BasicType/F2_Float2.java"
      target="_blank"> [예제코드] </a>

    <summary>[2진수 컴퓨터 저장 방식 ▼]</summary>
    <blockquote>
      <pre>
/* 2배씩 늘어날 때 */
[ 0]        1    = 0[011 1111 1]000 0000 0000 0000 0000 0000 
[ 1]        2    = 0[100 0000 0]000 0000 0000 0000 0000 0000 
[ 2]        4    = 0[100 0000 1]000 0000 0000 0000 0000 0000 
[ 3]        8    = 0[100 0001 0]000 0000 0000 0000 0000 0000 
[ 4]       16    = 0[100 0001 1]000 0000 0000 0000 0000 0000 
[ 5]       32    = 0[100 0010 0]000 0000 0000 0000 0000 0000 
[ 6]       64    = 0[100 0010 1]000 0000 0000 0000 0000 0000 
[ 7]      128    = 0[100 0011 0]000 0000 0000 0000 0000 0000 
[ 8]      256    = 0[100 0011 1]000 0000 0000 0000 0000 0000 
[ 9]      512    = 0[100 0100 0]000 0000 0000 0000 0000 0000 
[10]     1024    = 0[100 0100 1]000 0000 0000 0000 0000 0000 
[11]     2048    = 0[100 0101 0]000 0000 0000 0000 0000 0000 
[12]     4096    = 0[100 0101 1]000 0000 0000 0000 0000 0000 
[13]     8192    = 0[100 0110 0]000 0000 0000 0000 0000 0000
[14]    16384    = 0[100 0110 1]000 0000 0000 0000 0000 0000 
[15]    32768    = 0[100 0111 0]000 0000 0000 0000 0000 0000

/* 0.5배씩 줄어들 때 */
[ 0]        1    = 0[011 1111 1]000 0000 0000 0000 0000 0000 
[ 1] 0.500000    = 0[011 1111 0]000 0000 0000 0000 0000 0000 
[ 2] 0.250000    = 0[011 1110 1]000 0000 0000 0000 0000 0000
[ 3] 0.125000    = 0[011 1110 0]000 0000 0000 0000 0000 0000
[ 4] 0.062500    = 0[011 1101 1]000 0000 0000 0000 0000 0000
[ 5] 0.031250    = 0[011 1101 0]000 0000 0000 0000 0000 0000
[ 6] 0.015625    = 0[011 1100 1]000 0000 0000 0000 0000 0000
[ 7] 0.007813    = 0[011 1100 0]000 0000 0000 0000 0000 0000 
[ 8] 0.003906    = 0[011 1011 1]000 0000 0000 0000 0000 0000
[ 9] 0.001953    = 0[011 1011 0]000 0000 0000 0000 0000 0000
[10] 0.000977    = 0[011 1010 1]000 0000 0000 0000 0000 0000
[11] 0.000488    = 0[011 1010 0]000 0000 0000 0000 0000 0000
[12] 0.000244    = 0[011 1001 1]000 0000 0000 0000 0000 0000
[13] 0.000122    = 0[011 1001 0]000 0000 0000 0000 0000 0000
[14] 0.000061    = 0[011 1000 1]000 0000 0000 0000 0000 0000
[15] 0.000031    = 0[011 1000 0]000 0000 0000 0000 0000 0000

/* 2배씩 늘어날 때 + 1 */
[ 0]        2    = 0[100 0000 0]000 0000 0000 0000 0000 0000 
[ 1]        3    = 0[100 0000 0]100 0000 0000 0000 0000 0000
[ 2]        5    = 0[100 0000 1]010 0000 0000 0000 0000 0000
[ 3]        9    = 0[100 0001 0]001 0000 0000 0000 0000 0000 
[ 4]       17    = 0[100 0001 1]000 1000 0000 0000 0000 0000
[ 5]       33    = 0[100 0010 0]000 0100 0000 0000 0000 0000
[ 6]       65    = 0[100 0010 1]000 0010 0000 0000 0000 0000
[ 7]      129    = 0[100 0011 0]000 0001 0000 0000 0000 0000
[ 8]      257    = 0[100 0011 1]000 0000 1000 0000 0000 0000 
[ 9]      513    = 0[100 0100 0]000 0000 0100 0000 0000 0000
[10]     1025    = 0[100 0100 1]000 0000 0010 0000 0000 0000
[11]     2049    = 0[100 0101 0]000 0000 0001 0000 0000 0000
[12]     4097    = 0[100 0101 1]000 0000 0000 1000 0000 0000
[13]     8193    = 0[100 0110 0]000 0000 0000 0100 0000 0000
[14]    16385    = 0[100 0110 1]000 0000 0000 0010 0000 0000
[15]    32769    = 0[100 0111 0]000 0000 0000 0001 0000 0000

/* 0.5배씩 줄어들 때 + 1*/
[ 0]        2    = 0[100 0000 0]000 0000 0000 0000 0000 0000 
[ 1] 1.500000    = 0[011 1111 1]100 0000 0000 0000 0000 0000
[ 2] 1.250000    = 0[011 1111 1]010 0000 0000 0000 0000 0000
[ 3] 1.125000    = 0[011 1111 1]001 0000 0000 0000 0000 0000
[ 4] 1.062500    = 0[011 1111 1]000 1000 0000 0000 0000 0000
[ 5] 1.031250    = 0[011 1111 1]000 0100 0000 0000 0000 0000
[ 6] 1.015625    = 0[011 1111 1]000 0010 0000 0000 0000 0000
[ 7] 1.007813    = 0[011 1111 1]000 0001 0000 0000 0000 0000
[ 8] 1.003906    = 0[011 1111 1]000 0000 1000 0000 0000 0000
[ 9] 1.001953    = 0[011 1111 1]000 0000 0100 0000 0000 0000 
[10] 1.000977    = 0[011 1111 1]000 0000 0010 0000 0000 0000
[11] 1.000488    = 0[011 1111 1]000 0000 0001 0000 0000 0000
[12] 1.000244    = 0[011 1111 1]000 0000 0000 1000 0000 0000
[13] 1.000122    = 0[011 1111 1]000 0000 0000 0100 0000 0000
[14] 1.000061    = 0[011 1111 1]000 0000 0000 0010 0000 0000
[15] 1.000031    = 0[011 1111 1]000 0000 0000 0001 0000 0000

/* 음수 부호 처리 + 1*/
[ 0]        0    = 0[000 0000 0]000 0000 0000 0000 0000 0000 
[ 1] 0.500000    = 0[011 1111 0]000 0000 0000 0000 0000 0000 
[ 2] 0.750000    = 0[011 1111 0]100 0000 0000 0000 0000 0000
[ 3] 0.875000    = 0[011 1111 0]110 0000 0000 0000 0000 0000
[ 4] 0.937500    = 0[011 1111 0]111 0000 0000 0000 0000 0000
[ 5] 0.968750    = 0[011 1111 0]111 1000 0000 0000 0000 0000
[ 6] 0.984375    = 0[011 1111 0]111 1100 0000 0000 0000 0000
[ 7] 0.992188    = 0[011 1111 0]111 1110 0000 0000 0000 0000
[ 8] 0.996094    = 0[011 1111 0]111 1111 0000 0000 0000 0000
[ 9] 0.998047    = 0[011 1111 0]111 1111 1000 0000 0000 0000
[10] 0.999023    = 0[011 1111 0]111 1111 1100 0000 0000 0000 
[11] 0.999512    = 0[011 1111 0]111 1111 1110 0000 0000 0000
[12] 0.999756    = 0[011 1111 0]111 1111 1111 0000 0000 0000
[13] 0.999878    = 0[011 1111 0]111 1111 1111 1000 0000 0000
[14] 0.999939    = 0[011 1111 0]111 1111 1111 1100 0000 0000
[15] 0.999969    = 0[011 1111 0]111 1111 1111 1110 0000 0000

/* 정수 1을 소수라고 읽었을 때 */
[ 0] 1.4E-45        = 0[000 0000 0]000 0000 0000 0000 0000 0001 
[ 1] 2.8E-45        = 0[000 0000 0]000 0000 0000 0000 0000 0010 
[ 2] 5.6E-45        = 0[000 0000 0]000 0000 0000 0000 0000 0100 
[ 3] 1.1E-44        = 0[000 0000 0]000 0000 0000 0000 0000 1000 
[ 4] 2.24E-44       = 0[000 0000 0]000 0000 0000 0000 0001 0000 
[ 5] 4.5E-44        = 0[000 0000 0]000 0000 0000 0000 0010 0000 
[ 6] 9.0E-44        = 0[000 0000 0]000 0000 0000 0000 0100 0000 
[ 7] 1.794E-43      = 0[000 0000 0]000 0000 0000 0000 1000 0000 
[ 8] 3.59E-43       = 0[000 0000 0]000 0000 0000 0001 0000 0000 
[ 9] 7.175E-43      = 0[000 0000 0]000 0000 0000 0010 0000 0000 
[10] 1.435E-42      = 0[000 0000 0]000 0000 0000 0100 0000 0000 
[11] 2.87E-42       = 0[000 0000 0]000 0000 0000 1000 0000 0000 
[12] 5.74E-42       = 0[000 0000 0]000 0000 0001 0000 0000 0000 
[13] 1.14794E-41    = 0[000 0000 0]000 0000 0010 0000 0000 0000
[14] 2.2959E-41     = 0[000 0000 0]000 0000 0100 0000 0000 0000
[15] 4.5918E-41     = 0[000 0000 0]000 0000 1000 0000 0000 0000 
[16] 9.18355E-41    = 0[000 0000 0]000 0001 0000 0000 0000 0000
[17] 1.83671E-40    = 0[000 0000 0]000 0010 0000 0000 0000 0000
[18] 3.67342E-40    = 0[000 0000 0]000 0100 0000 0000 0000 0000
[19] 7.34684E-40    = 0[000 0000 0]000 1000 0000 0000 0000 0000
[20] 1.469368E-39   = 0[000 0000 0]001 0000 0000 0000 0000 0000
[21] 2.938736E-39   = 0[000 0000 0]010 0000 0000 0000 0000 0000
[22] 5.877472E-39   = 0[000 0000 0]100 0000 0000 0000 0000 0000
[23] 1.17549435E-38 = 0[000 0000 1]000 0000 0000 0000 0000 0000
[24] 2.3509887E-38  = 0[000 0001 0]000 0000 0000 0000 0000 0000
[25] 4.7019774E-38  = 0[000 0001 1]000 0000 0000 0000 0000 0000
[26] 9.403955E-38   = 0[000 0010 0]000 0000 0000 0000 0000 0000
[27] 1.880791E-37   = 0[000 0010 1]000 0000 0000 0000 0000 0000 
[28] 3.761582E-37   = 0[000 0011 0]000 0000 0000 0000 0000 0000
[29] 7.523164E-37   = 0[000 0011 1]000 0000 0000 0000 0000 0000
[30] 1.5046328E-36  = 0[000 0100 0]000 0000 0000 0000 0000 0000
[31] 3.0092655E-36  = 0[000 0100 1]000 0000 0000 0000 0000 0000
    </pre>
    </blockquote>
    </details>
    <h2>덧셈</h2>
    컴퓨터의 덧셈은 다음과 같이 처리됩니다.
    <ul>
      <li>0 + 0 = 0</li>
      <li>0 + 1 = 1</li>
      <li>1 + 0 = 1</li>
      <li>1 + 1 = 0(올림)</li>
    </ul>
    예를들면:
    <blockquote>
      \( 00000000{\color{red}1}010_{(2)} -> 10_{(10)} \)<br>
      \( 00000000{\color{red}1}100_{(2)} -> 12_{(10)} \)<br>
      (+) ────────────<br>
      \( 0000000{\color{red}1}0110_{(2)} -> 22_{(10)} \)
    </blockquote>

    <h2>보수 : 음수의 계산</h2>
    음수를 저장하고자 할 때, 0은 +로 1을 -로 인식하는 방법이 있습니다. 예를들면:
    <blockquote>
      \( {\color{red}0}00000001100_{(2)} -> 12_{(10)} \)<br>
      \( {\color{red}1}00000001100_{(2)} -> {\color{red}-}12_{(10)} \)
    </blockquote>
    &nbsp;여기서 연산에 제동이 걸립니다. 결과값이 음수일 때 처리가 쉽지 않았습니다. 이를 좀 더 쉽게 하기 위해, 음수로 되어 있는 이진수에 비트를 모두 뒤집어 줍니다<q>(0 → 1, 1 → 0). 이를
      1의 보수라고 하며,</q> 이 때 음수건 양수건 간에 덧셈 연산 후 값이 실제 값과 거의 유사하게 됩니다. 예를 들면,
    <blockquote>
      \( {\color{red}0}00000001100_{(2)} -> 12_{(10)} \)<br>
      \( {\color{red}11111111}00{\color{red}11}_{(2)} -> {\color{red}-}12_{(10)} \)<br>
      (+) ────────────<br>
      \( {\color{red}111111111111}_{(2)} -> {\color{red}-}0_{(10)} \)
    </blockquote>
    <blockquote>
      \( 00000001100_{(2)} -> 12_{(10)} \)<br>
      \( 11111110110_{(2)} -> {\color{red}-}9_{(10)} \)<br>
      (+) ────────────<br>
      \( 00000000010_{(2)} -> 2_{(10)} \)
    </blockquote>
    &nbsp;위 두수의 결과값은 -1이 나옵니다. 언제나 두 수의 연산 후 값은 -1차이가 납니다. 그러므로, 만약 <q>결과값에 무조건 1을 더한다면 덧셈기 하나만 가지고 모든 연산을 할 수 있게
      됩니다.</q> 따라서, 연산시 1을 더할 것이 아니고, 음수에 1을 더함으로써 음수가 연산될 때는 반드시 1을 더한 값이 저장되도록 합니다.
    <blockquote>
      \( 000000001111_{(2)} -> 15_{(10)} \)<br>
      \( 11111111000{\color{red}1}_{(2)} -> {\color{red}-}15_{(10)} \)<br>
      (+) ────────────<br>
      \( 00000000000_{(2)} -> 0_{(10)} \)
    </blockquote>
    <blockquote>
      \( 00000001100_{(2)} -> 12_{(10)} \)<br>
      \( 1111111011{\color{red}1}_{(2)} -> {\color{red}-}9_{(10)} \)<br>
      (+) ────────────<br>
      \( 00000000011_{(2)} -> 3_{(10)} \)
    </blockquote>
    <table class="grid">
      <tr>
        <td>10진법 :</td>
        <td><input type="number" id="decimalNeg" value=1 onkeyup="updateNeg(this.value)"
            onchange="updateNeg(this.value)"></td>
        <td style="text-align: left;">
          <button class="green" onclick="upNeg()">Up</button>
          <button class="green" onclick="downNeg()">Down</button>
        </td>
      </tr>
      <tr>
        <td>절대값 : </td>
        <td><input type="text" id="binary-abs" disabled></td>
      </tr>
      <tr>
        <td>1의 보수 : </td>
        <td><input type="text" id="binary-1comp" disabled></td>
      </tr>
      <tr>
        <td>2의 보수 : </td>
        <td><input type="text" id="binary-2comp" disabled></td>
      </tr>
    </table>

    <h1>마치며</h1>

    <h2>"3.9 + 5.1 = 9 입니까? 9.0입니까? 휴먼?"</h2>
    <a href="https://blog.naver.com/seohyun0903/222831160555">링크: 일본 실제 초등학생문제</a><br><br>
    컴퓨터의 세계에서 1과 001은 다른 수입니다. 마찬가지로, 9와 9.0은 다릅니다. 해당 초등학생은 9.0이라고 답해서 틀렸지만, 컴퓨터는 100% 9.0이라고 대답합니다.<br>
    컴퓨터에게 숫자를 알려줄 때엔 몇 자리수인지 알려줘야 합니다. 000111은 7이지만 111은 -1이 될 수 있으니까요.<br><br>

    초기의 컴퓨터는 8자리를 기본으로 사용했습니다. 이후 16자리, 32자리로 늘어났으며, 꽤 오랜시간 동안 32자리 컴퓨터를 사용했습니다. 현재는 64자리 컴퓨터를 사용하고 있습니다.<br><br>

    8자리로 표현 할 수 있는 가장 큰 수는 255입니다.<br>
    16자리로 표현 할 수 있는 가장 큰 수는 65535입니다.<br>
    32자리는 40억이 넘죠. 왜 한 동안 32자리 컴퓨터를 사용했는지 감이 오시죠? 꽤 큰수로 보이지만 4Gbyte밖에 안됩니다. 영화 한편 보기도 힘들겠네요.<br>
    컴퓨터에게 "1을 저장해"라고 하면 안됩니다.<br>
    8자리수 1을 저장 할 것인지, 16자리수 1을 저장 할 것인지 알려줘야 합니다.<br><br>

    컴퓨터에겐 1과 1.0을 바라보는 저장하는 방식이 다릅니다.<br>
    1.0을 저장하려면 "소수점 형식으로 1을 저장해줘"라고 말해야 합니다.
  </article>
</body>

</html>
<script>
  function update(value) {
    document.getElementById('binary').value = Number(value).toString(2);
    document.getElementById('penta').value = Number(value).toString(5);
    document.getElementById('octa').value = Number(value).toString(8);
    document.getElementById('hexa').value = Number(value).toString(16);
  }
  function up() {
    var decimal = document.getElementById('decimal');
    decimal.value = Number.parseInt(decimal.value) + 1;
    update(decimal.value);
  }
  function down() {
    var decimal = document.getElementById('decimal');
    if (Number.parseInt(decimal.value) != 0) {
      decimal.value = Number.parseInt(decimal.value) - 1;
      update(decimal.value);
    }
  }

  function updateNeg(value) {
    value = Number.parseInt(value)
    var strval = "";

    if (value < 0) {
      //절대값
      for (var i = 0; i < (8 - Number(-value).toString(2).length); i++) {
        strval += "0";
      }
      strval += Number(-value).toString(2);
      document.getElementById('binary-abs').value = strval;

      // 보수 연산
      value = 255 + value;

      // 1의 보수 - 음수
      strval = "";
      for (var i = 0; i < (8 - Number(value).toString(2).length); i++) {
        strval += "0";
      }
      strval += Number(value).toString(2);
      document.getElementById('binary-1comp').value = strval;

      // 2의 보수 - 음수

      strval = "";
      for (var i = 0; i < (8 - Number(value + 1).toString(2).length); i++) {
        strval += "0";
      }
      strval += Number(value + 1).toString(2);

      document.getElementById('binary-2comp').value = strval;

    } else {
      for (var i = 0; i < (8 - Number(value).toString(2).length); i++) {
        strval += "0";
      }
      strval += Number(value).toString(2);

      document.getElementById('binary-abs').value = strval;
      document.getElementById('binary-1comp').value = strval;
      document.getElementById('binary-2comp').value = strval;
    }
  }
  function upNeg() {
    var decimal = document.getElementById('decimalNeg');
    if (Number.parseInt(decimal.value) >= 255) {
      decimal.value = -255;
    } else {
      decimal.value = Number.parseInt(decimal.value) + 1;
    }
    updateNeg(decimal.value);
  }
  function downNeg() {
    var decimal = document.getElementById('decimalNeg');
    if (Number.parseInt(decimal.value) <= -255) {
      decimal.value = 255;
    } else {
      decimal.value = Number.parseInt(decimal.value) - 1;
    }
    updateNeg(decimal.value);
  }
</script>