<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" lang="ko">
  <!-- 모바일 스케일 고정 -->
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta discription="튜토리얼을 제공합니다.">
  <meta keywords="iseohyun, 튜토리얼, canvas, 팁">
  <meta author="iseohyun">

  <!-- 페이지 타이틀 -->
  <title>팁: canvas - iseohyun </title>
  <link rel="shortcut icon" type="image/x-icon" href="/source/icon_seohyun.svg">

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-453XSP5W9M"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-453XSP5W9M');
  </script>

  <!-- 소스코드 스타일 -->
  <link rel="stylesheet" href="/highlight/styles/base16/cupertino.min.css" />
  <script src="/highlight/highlight.min.js"></script>
  <script src="/highlight/highlightjs-line-numbers.js"></script>

  <!-- 목차 생성 -->
  <script src="/modules/script.js" defer></script>

  <!-- 공통스킨 -->
  <style type="text/css">
    @import url("/style.css");
  </style>
</head>

<body>
  <article>
    <h1 style="margin-top: 50px;">요약</h1>
    <style>
      #canvas-syntax tr+tr>td {
        font-family: D2Coding;
      }
    </style>
    <table id="canvas-syntax" class="all-td-left">
      <caption>canvas 문법 요약</caption>
      <thead>
        <td>분류</td>
        <td>코드</td>
      </thead>
      <tr></tr>
      <tr>
        <td>객체</td>
        <td>
          ctx.<em>beginPath</em>(); <samp>// 그리기 시작</samp><br>
          ctx.<em>endPath</em>(); <samp>// 그리기 끝</samp><br>
          ctx = new <em>Path2D</em>(); <samp>// 빈 객체 생성</samp><br>
          ctx = new <em>Path2D</em>(path); <samp>// 다른 Path2D 또는 SVG 객체 복사</samp>
        </td>
      </tr>
      <tr>
        <td>도형</td>
        <td>
          ctx.<em>fillRect</em>(25, 25, 100, 100); <samp>// 채워진 사각형(좌표x,y, 크기x,y)</samp><br>
          ctx.<em>strokeRect</em>(150, 25, 100, 100); <samp>// 빈 사각형(…)</samp><br>
          ctx.<em>clearRect</em>(350,50,100,50); <samp>// 지우기 사각형(…)</samp><br>
        </td>
      </tr>
      <tr>
        <td>선</td>
        <td>
          ctx.<em>lineTo</em>(0, 100); <samp>// 선 그리기(좌표x, y)</samp><br>
          ctx.<em>moveTo</em>(0, 100); <samp>// 뗀선 그리기(좌표x, y)</samp><br>
          ctx.<em>arc</em>(75, 75, 50, 0, Math.PI * 2, true); <samp>// 원호 그리기(좌표x,y, 반지름, 시작각, 끝각, 시계방향=true)</samp><br>
          ctx.<em>quadraticCurveTo</em>(100, 50, 50, 100); <samp>// 2차곡선(제어점x, y, 끝점x, y)</samp><br>
          ctx.<em>bezierCurveTo</em>(100, 50, 10, 50, 50, 100); <samp>// 3차곡선(제어점1x, y, 제어점2x, y, 끝점x, y)</samp><br>
          ctx.<em>ctx.fillStyle = </em> = #0000; <samp>// 선 두께</samp><br>
          ctx.<em>lineWidth</em> = 3; <samp>// 선 두께</samp><br>
          ctx.<em>strokeStyle</em> = 'butt' | 'round' | 'square'; <samp>// 선 끝 처리</samp><br>
          ctx.<em>lineJoin</em> = 'round' | 'bevel' | 'miter'; <samp>// 선 연결점 처리</samp><br>
          ctx.<em>miterLimit</em> = 10; <samp>// 선 연결점 임계(허용하는 최대) 각</samp><br>
          ctx.<em>setLineDash</em>([4, 2]); <samp>// 점선 그리기 [주기1, 주기2, ...]</samp><br>
          ctx.<em>lineDashOffset</em>= 10; <samp>// 점선 오프셋</samp>
        </td>
      </tr>
      <tr>
        <td>색상</td>
        <td>
          ctx.<em>fillStyle</em> = '#0000' <samp>// 채우기 색</samp><br>
          myColor = ctx.<em>createLinearGradient</em>(0, 0, 100, 100); <samp>// 그라데이션(시작x, y, 끝x, y);</samp><br>
          myColor = ctx.<em>createRadialGradient</em>(1,2,3,4,5,6); <samp>// 원형 그라데이션 (시작x, y, r, 끝x, y,
            r);</samp><br>
          myColor.<em>addColorStop</em>(0, '#0000'); <samp>// 그라데이션 세부 설정(0 ~ 1 사이 소수, 색);</samp><br>
          <hr>
          ctx.<em>strokeStyle</em> = myColor | '#0000'; <samp>// 외곽선 색</samp></br>
          ctx.<em>fillStyle</em> = myColor | '#0000'; <samp>// 채우기 색</samp>
          <hr>
          ctx.<em>stroke</em>(); <samp>// 외곽선 그리기</samp><br>
          ctx.<em>fill</em>(); <samp>// 경로 채우기 [() | (경로) | (규칙) | (경로, 규칙)], 규칙 = [nonzero | evenodd]</samp>
        </td>
      </tr>
      <tr>
        <td>이미지</td>
        <td>
          <style>
            .patternImage {
              background-color: #ffa;
            }

            .ctxImg {
              background-color: #aff;
            }
          </style>
          &lt;canvas id="<span class="patternImage">patternImage</span>" style="display:none;">&lt;/canvas><br>
          var <span class="patternImage">patternImage</span> = document.getElementById("<span
            class="patternImage">patternImage</span>");<br>
          var <span class="ctxImg">ctxImg</span> = <span class="patternImage">patternImage</span>.getContext("2d");<br>
          var img = new <em>Image</em>();<samp>// img 테그를 가져올 수 도 있음</samp><br>
          img.src = "https://...";<br>
          img.onload = function () {<br>
          &nbsp; <span class="ctxImg">ctxImg</span>.<em>drawImage</em>(img, 0, 0, newWidth, newHeight);<br>
          &nbsp; var ptrn = ctx.<em>createPattern</em>(<span &nbsp; class="patternImage">patternImage</span>,
          "repeat");<br>
          &nbsp; &ctx.<em>fillStyle</em> = ptrn;<br>
          ctx.<em>drawImage</em>(이미지, 시작점x, y); <samp>// 이미지는 html tag를 getElementById로 불러올 수도 있다.</samp><br>
          ctx.<em>drawImage</em>(이미지, 시작점x, y, 조정될 크기w, h); <samp>// 크기조정</samp><br>
          ctx.<em>drawImage</em>(이미지, 잘라낼크기x, y, w, h, 붙여넣을크기x, y, w, h); <samp>// 이미지 자르기</samp><br>
        </td>
      </tr>
      <tr>
        <td>그림자</td>
        <td>
          ctx.<em>shadowOffsetX</em> = 2;<br>
          ctx.<em>shadowOffsetY</em> = 2;<br>
          ctx.<em>shadowBlur</em> = 2;<br>
          ctx.<em>shadowColor</em> = "#0007";
          <hr>
          ctx.<em>filter</em> = "CSS 필터";<smap>// 중복 적용 가능</smap>
          <style>
            .inner-table {
              margin: 0;
            }
          </style>
          <table class="all-td-left inner-table">
            <thead>
              <tr>
                <th>효과</th>
                <th>함수</th>
                <th>인자</th>
                <th>예시</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>흐리게</td>
                <td>blur</td>
                <td>(번짐길이)</td>
                <td>blur(2px)</td>
              </tr>
              <tr>
                <td>밝기</td>
                <td>brightness</td>
                <td>(밝기율%)</td>
                <td>brightness(40%)</td>
              </tr>
              <tr>
                <td>대조</td>
                <td>contrast</td>
                <td>(대조율%)</td>
                <td>contrast(200%)</td>
              </tr>
              <tr>
                <td>그림자</td>
                <td>drop-hadow</td>
                <td>(그림자거리x, y, 번짐크기, 색)</td>
                <td>drop-shadow(5px 5px 5px #444)</td>
              </tr>
              <tr>
                <td>회색비</td>
                <td>grayscale</td>
                <td>(회색조%)</td>
                <td>grayscale(50%)</td>
              </tr>
              <tr>
                <td>색 회전</td>
                <td>hue-rotate</td>
                <td>(회전각deg)</td>
                <td>hue-rotate(90deg)</td>
              </tr>
              <tr>
                <td>반전</td>
                <td>invert</td>
                <td>(반전율%)</td>
                <td>invert(100%)</td>
              </tr>
              <tr>
                <td>투명도</td>
                <td>opacity</td>
                <td>(투명률%)</td>
                <td>opacity(25%)</td>
              </tr>
              <tr>
                <td>채도</td>
                <td>saturate</td>
                <td>(채도%)</td>
                <td>saturate(30%)</td>
              </tr>
              <tr>
                <td>갈색조</td>
                <td>sepia</td>
                <td>(반영율%)</td>
                <td>sepia(60%)</td>
              </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>폰트</td>
        <td>
          ctx.<em>font</em> = "italic bolder 48px '궁서'";<br>
          ctx.<em>textAlign</em> = start; <samp>// 텍스트 정렬 : start, end, left, right, center</samp><br>
          ctx.<em>textBaseline</em> = top; <samp>// 글자 출력 높이 : top, hanging, middle, alphabetic, ideographic,
            bottom</samp><br>
          ctx.<em>direction</em> = ltr; <samp>// 글자 방향 : ltr(left to right), rtl, inherit(system)</samp>
          <hr>
          var text = ctx.measureText("input text");<br>
          text.width <samp>// 입력한 텍스트의 가로 길이</samp>
        </td>
      </tr>
      <tr>
        <td>저장<br>불러오기</td>
        <td>
          ctx.<em>save</em>();<br>
          ctx.<em>restore</em>();<br>
          ctx.<em>translate</em>(x축 이동, y축 이동); <samp>// 이동</samp><br>
          ctx.<em>ratate</em>(각도(라디안)); <samp>// 회전 : 원점 기준 시계방향으로 회전</samp><br>
          ctx.<em>scale</em>(x확대율, y확대율); <samp>// 확대, 응용 : -1을 넣어 뒤집힌 효과도 가능</samp><br>
          ctx.<em>transform</em>(a, b, c, d, e, f); <samp>// 3차원 회전</samp><br>
          ctx.<em>resetTransform</em>(); = ctx.transform(1,0,0,1,0,0);<br>
          ctx.<em>clip</em>(); <samp>// 자르기</samp>
        </td>
      </tr>
      <tr>
        <td>이벤트</td>
        <td>
          <em>setInterval</em>(함수명, delay); <samp>// delay = 1/1000초, 계속 호출</samp><br>
          <em>setTimeout</em>(함수명, delay); <samp>// 한번만 호출</samp>
          <hr>
          <em>addEventListener</em>("이벤트명", 콜백함수); <samp>// mouseout, mouseover</samp><br>
          window.<em>requestAnimationFrame</em>(콜백함수); <samp>//애니메이션으로 호출할 함수</samp><br>
          window.<em>cancelAnimationFrame</em>(핸들러); <samp>// 애니메이션 취소</samp>
        </td>
      </tr>
    </table>

    <h1>다운로드</h1>
    <iframe id="download-iframe" src="demo/demo_click_ball.html" width="600" height="330"></iframe>
    <!-- <a id="download-a">download canvas.png</a> -->
    <button onclick="download()">현재 모습 다운로드</button>
    <blockquote>
      canvas = document.getElementById("canvas");<br>
      <samp>// 호출이 되는 순간의 모습을 이미지로 저장합니다.</samp><br>
      const pngDataUri = canvas.toDataURL("image/png");<br>
      <samp>// 링크에 주소와 파일명을 저장해서 클릭되었을 때 이미지를 다운로드 합니다.</samp><br>
      var link = document.getElementById("link");<br>
      link.href = pngDataUri;<br>
      link.download = "canvas.png";
    </blockquote>
    <script defer>
      var iframe = document.getElementById("download-iframe");
      var canvas;
      // iframe의 조작 시점은, 파일이 로딩 된 후여야 합니다.
      iframe.onload = function () {
        // iframe의 document형식으로 접근해야합니다.
        canvas = iframe.contentWindow.document.getElementById("canvas");
      }

      // 버튼이 눌렸을 때, 동작합니다.
      function download() {
        // 현재의 모습을 캡쳐합니다.
        const pngDataUri = canvas.toDataURL("image/png");
        // 임시 엥커(anchor)를 만들어서 다운로드 후, 삭제합니다.
        var link = document.createElement("a");
        link.href = pngDataUri;
        link.download = "canvas.png";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    </script>

    <h3>추가</h3>
    <p>
      iframe안에 있는 canvas를 조작하는 방법, button을 클릭했을 때 다운로드 함수를 만드는 방법을 기술합니다.
    </p>
    <pre><code>&lt;script>
  var iframe = document.getElementById("download-iframe");
  var canvas;
  // iframe의 조작 시점은, 파일이 로딩 된 후여야 합니다.
  iframe.onload = function () {
    // iframe의 document형식으로 접근해야합니다.
    canvas = iframe.contentWindow.document.getElementById("canvas");
  }

  // 버튼이 눌렸을 때, 동작합니다.
  function download() {
    // 현재의 모습을 캡쳐합니다.
    const pngDataUri = canvas.toDataURL("image/png");
    // 임시 엥커(anchor)를 만들어서 다운로드 후, 삭제합니다.
    var link = document.createElement("a");
    link.href = pngDataUri;
    link.download = "canvas.png";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
&lt;/script></code></pre>

    <h1>MSDN에서 전하는 팁</h1>
    <h2>반복객체 미리 그리기</h2>
    <p>
      반복 작업이 되는 그림을 미리 그린 후 주 캔버스에 넣으면 랜더링을 줄일 수 있습니다.
    </p>
    <pre><code class="language-java">myCanvas.offscreenCanvas = document.createElement('canvas');
myCanvas.offscreenCanvas.width = myCanvas.width;
myCanvas.offscreenCanvas.height = myCanvas.height;

myCanvas.getContext('2d').drawImage(myCanvas.offScreenCanvas, 0, 0);</code></pre>

    <h2>부동소수점 피하기</h2>
    <p>
      부동소수점은 부가적인 픽셀렌더링이 발생됩니다.
      Math.floor()를 사용하여, 정수화합니다.
    </p>

    <h2>drawImage에서 크기조정 피하기</h2>
    <p>
      오프스크린(offscreen) 캔버스에서 캐시하면 유리합니다.
      만약 큰 배경이미지는 CSS의 background속성을 이용하면 매 틱마다 랜더링하지 않아도 됩니다.
      또한 CSS 변환은 GPU를 사용하기 때문에 더 빠릅니다.
    </p>

    <h2>여러개의 캔버스를 사용하기</h2>
    <p>
      아래 예시는 게임UI를 상정하였습니다.
      움직임이 적은 배경UI를 렌더링에서 최대한 배제할 수 있습니다.
    </p>

    <pre><code class="language-html">&lt;div id="stage">
  &lt;canvas id="ui-layer" width="480" height="320">&lt;/canvas>
  &lt;canvas id="game-layer" width="480" height="320">&lt;/canvas>
  &lt;canvas id="background-layer" width="480" height="320">&lt;/canvas>
&lt;/div>
    
&lt;style>
  #stage {
    width: 480px;
    height: 320px;
    position: relative;
    border: 2px solid black;
  }
  
  canvas { position: absolute; }
  #ui-layer { z-index: 3; }
  #game-layer { z-index: 2; }
  #background-layer { z-index: 1; }
&lt;/style></code></pre>

    <h2>투명도 사용을 가급적 피하기</h2>
    <p>
      투명 배경을 사용하지 않을 때 아래 옵션을 사용하여 최적화 할 수 있습니다.
    </p>

    <pre><code class="language-java">// 투명 배경을 피하는 방법
var ctx = canvas.getContext('2d', { alpha: false });</code></pre>

    <h2>기타 팁들</h2>
    <ul>
      <li>배치 캔버스를 함께 호출합니다. 예를 들어 여러 개의 개별 선 대신 다각형 선을 그립니다.</li>
      <li>불필요한 캔버스 상태 변경을 피하십시오.</li>
      <li>화면의 차이만 렌더링하고 완전히 새로운 상태로 렌더링하지 마십시오.</li>
      <li>가능하면 shadowBlur 속성을 사용하지 마십시오.</li>
      <li>가능하면 텍스트 렌더링을 피하십시오.</li>
      <li>캔버스를 지우는 여러 가지 방법을 시도해보십시오 (clearRect() vs. fillRect() vs. 캔버스 크기 조정).</li>
      <li>애니메이션에서는 window.setInterval() 대신 window.requestAnimationFrame()을 사용하십시오.</li>
      <li>무거운 물리 연산 라이브러리를 주의하십시오.</li>
    </ul>
  </article>
</body>

</html>