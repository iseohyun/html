<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" lang="ko">
  <!-- 모바일 스케일 고정 -->
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta description="정보처리기사 정보 모음">
  <meta keywords="소프트웨어 설계, 정보처리기사">
  <meta author="iseohyun">
  <!-- 페이지 타이틀 -->
  <title>소프트웨어 설계: 정보처리기사</title>
  <link rel="shortcut icon" type="image/x-icon" href="/source/icon_seohyun.svg">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-453XSP5W9M"></script>
  <script>window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'G-453XSP5W9M');</script>
  <!-- 소스코드 스타일 -->
  <link rel="stylesheet" href="/highlight/styles/base16/cupertino.min.css" />
  <script src="/highlight/highlight.min.js"></script>
  <script src="/highlight/highlightjs-line-numbers.js"></script>
  
  <!-- 수식 -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- 차트 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- 목차 생성 -->
  <script src="/modules/script.js" defer></script>
  <!-- 공통스킨 -->
  <style type="text/css">
    @import url("/style.css");

    ol,
    ul {
      margin-left: 0.2em;
      padding-left: 0;
    }

    li {
      line-height: 1.2em;
      margin-bottom: 0;
    }

    /* li:hover {
      background-color: #FFA;
      color: #000;
      font-size: 1.01em;
      animation: increaseFontSize 0.5s;
    }

    @keyframes increaseFontSize {
      from {
        font-size: 1em;
      }

      to {
        font-size: 1.01em;
      }
    }

    li li:hover {
      background-color: #FF0;
    }

    li li li:hover {
      background-color: #FE0;
    } */

    li>ol,
    li>ul {
      font-size: 0.95em;
      margin-top: 0.1em;
      margin-bottom: 0.35em;
    }

    article>ul,
    article>ol {
      margin-left: 2.3em;
    }

    article>ul>li,
    article>ol>li {
      line-height: 1.35em;
      margin-bottom: 0.3em;
    }

    td>ul,
    td>ol {
      margin-left: 0.8em;
    }

    ul>li::marker {
      /* content: "· "; */
      content: "•"; /* bull */
    }

    ul>li>ul>li::marker {
      content: "- ";
      content: "∘ ";
    }

    ul>li>ul>li>ul>li::marker {
      content: ": ";
    }

    .list-title {
      line-height: 2.5em;
    }

    .list-title+ol,
    .list-title+ul {
      padding-top: 0px;
      margin-top: 0px;
      margin-bottom: 5px;
    }

    article>span.list-title {
      margin-left: 1em;
      color: #000;
      font-weight: bold;
    }

    .list-title+ul>li:first-child,
    .list-title+ol>li:first-child {
      line-height: 0.5em;
      padding-bottom: 0.5em;
    }

    td>.list-title+ul>li:first-child,
    td>.list-title+ol>li:first-child {
      line-height: 0;
      padding-bottom: 0.5em;
    }

    td>.list-title+ul li,
    td>.list-title+ol li {
      line-height: 1em;
    }

    b {
      color: #000;
    }

    caption {
      line-height: 0.8em;
      font-size: 0.8em;
    }

    table table {
      margin: 5px 0;
      padding: 0;
      border-color: #bbb;
    }

    table table th {
      background-color: #bbb;
    }
  </style>
</head>

<body>
  <article>
    <h1>소프트웨어 생명 주기</h1>
    <h2>소프트웨어 생명 주기</h2>
    <p>
      Software가 개발되어 폐기 될 때까지, 개발과 유지보수에 대한 전략(체계성, 이론)<br>
      전과정 문서화: 타당성 검토 > 계획 > 요구(위험성)분석 > 설계 > 구현(개발) > 시험 > 유지보수
    </p>
    <table class="all-td-left">
      <caption>Software life Cycle</caption>
      <thead>
        <tr>
          <th>유형</th>
          <th>내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>폭포수 모형(Waterfall Model)</td>
          <td>각 단계를 확실히 마무리하고 다음 단계를 진행</td>
        </tr>
        <tr>
          <td>프로토타입 모형(Prototype Model)</td>
          <td>시제품(Prototype)을 만들어 최종 결과물 예측<br>
            시제품 제작과정에서 별도의 개발언어가 사용될 수 있다.(오버헤드)<br>
            시제품 제작목적은 가능성, 고객 요구사항 점검(수정, 추가)이 있다.
          </td>
        </tr>
        <tr>
          <td>나선형 모형(Spiral Model)</td>
          <td>
            프로토타입을 지속적으로 발전<br>
            위험 관리(Risk Management)측면에서 바라봄<br>
            여러번의 개발 주기를 거침<br>
            요구사항이나 아키텍처의 이해가 어렵거나, 중심이 되는 기술에 문제가 있는 경우 진행
          </td>
        </tr>
        <tr>
          <td>애자일 모형(Agile Model)</td>
          <td>
            Agile: 날렵한, 기민한.<br>
            개발주기에 고객의 요구사항을 최우선으로 처리<br>
            <span class="list-title"><b>스크럼</b>(scrum, 럭비) - 럭비의 셋업. 서로 밀치락달치락하는 사람들</span>
            <ol>
              <li>백로그(Product Backlog): 요구사항(기능) 목록 + 우선순위</li>
              <li>팀(스크럼) 단위, 원할한 의사소통</li>
              <li>
                스프린트(Sprint, 단거리 전력질주, 1~4주): 담당자 배정(되도록 자발적)<br>
                - 매일 스크럼 회의(Daily Scrum Meeting): 매일 15분, 소멸차트(Burn-down Chart) 작성<br>
                - 검토 회의(Sprint Review): 주 1시간, 책임자(PO) 및 사용자 앞에서 테스팅<br>
                - 회고(Sprint Retrospective): 스프린트 단위, 보완점 확인
              </li>
            </ol>
            <table class="last-td-left">
              <caption>스크럼</caption>
              <thead>
                <tr>
                  <th>이해관계자</th>
                  <th>역할</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>제품 책임자(PO; Product Owner)</td>
                  <td>이해관계자의 의견을 종합하여 백로그 작성</td>
                </tr>
                <tr>
                  <td>스크럼 마스터(SM; Scrum Master)</td>
                  <td>팀장, 회의 주관</td>
                </tr>
                <tr>
                  <td>개발팀원(DT; Development Team)</td>
                  <td>팀당 약 7~8명</td>
                </tr>
              </tbody>
            </table>

            <span class="list-title"><b>익스트림 프로그래밍</b>(eXtreme Programming, XP)</span>
            <ul>
              <li>문서보다 코드(결과)를 우선, 고객의 요구가 우선</li>
              <li>핵심가치(5가지): 의사소통(Communication), 단순성(Simplicity), 용기(Courage), 존중(Respect), 피드백(Feedback)</li>
              <li>사용자 스토리(User Story): 고객 사용 시나리오 + 상황별 시나리오(Test Case)</li>
              <li>스파이크(Spike): 별도로 만드는 간단한 프로그램</li>
              <li>이터레이션(Iteration): 릴리즈를 세분화한 단위(개당 1~3주)</li>
              <li>인수 테스트(Acceptance Test): 릴리즈 단위로 고객이 직접 수행</li>
              <li>소규모 릴리즈(Small Release): 고객의 반응을 기능별 확인</li>
              <li>계속적인 통합(Continuous Intergration): 모듈단위로 나누어 개발된 코드들을 지속적 병합</li>
              <li>디자인 개선(Design improvement), 리펙토링(Refactoring): 기능 변경 없는 재구성</li>
            </ul>

            <br>

            <b>애자일 선언</b>(Agile Monifesto) - 2001.<br>
            <span class="list-title">핵심가치(4가지)</span>
            <ol>
              <li>프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.</li>
              <li>방대한 문서보다는 실행되는 SW에 더 가치를 둔다.</li>
              <li>계약 협상보다는 고객과 협업에 더 가치를 둔다.</li>
              <li>계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.</li>
            </ol>

            <span class="list-title">애자일 개발 실행 지침(12가지)</span>
            <ol>
              <li>유용한 소프트웨어를 빠르고, 지속적으로 제공하여 고객을 만족시킨다.</li>
              <li>개발 막바지라도 요구사항 변경을 적극 수용한다.</li>
              <li>몇 개월이 아닌 몇 주 다위로 실행되는 소프트웨어를 제공한다.</li>
              <li>고객과 개발자가 프로젝트 기간에 함께 일한다.</li>
              <li>개발에 대한 참여 의지가 확실한 사람들로 팀을 구성하고, 필요한 개발 환경과 지원을 제공하여, 일을 잘 끝낼 수 있도록 신뢰한다.</li>
              <li>같은 사무실에서 얼굴을 맞대고 의견을 나눈다.</li>
              <li>개발의 진척도를 확인하는 1차 기준은 작동하는 소프트웨어이다.</li>
              <li>지속 가능한 개발을 장려하고 일정한 속도로 개발을 진행한다.</li>
              <li>기술적 우수성과 좋은 설계에 지속적인 관심을 기울이면 민첩성이 향상된다.</li>
              <li>단순화를 추구한다.</li>
              <li>최상의 아키텍처, 명확한 요구사항, 최상의 설계는 자기 스스로 일을 주도하는 조직적인 팀으로부터 나온다.</li>
              <li>더 효과적인 팀이 될 수 있는 방안을 정기적으로 깊이 고민하고 그에 따라 팀의 행동을 조정한다.</li>
            </ol>
          </td>
        </tr>
      </tbody>
    </table>
    <h2>현행 시스템 파악</h2>
    <p>
      시스템 구성과 관련하여, 제약조건을 미리 파악해 놓아야 합니다.
    </p>
    <table class="last-td-left">
      <caption>범주별 고려할 사항</caption>
      <thead>
        <tr>
          <th>범주</th>
          <th>주요사항</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>시스템 구성</td>
          <td>개괄, 조직별 주 업무 파악</td>
        </tr>
        <tr>
          <td>시스템 기능 구성</td>
          <td>세부, 조직별 세부 업무 단위의 활동(기능) 파악</td>
        </tr>
        <tr>
          <td>인터페이스 구성</td>
          <td>송수신 데이터의 종류, 형식(프로토콜), 내용, 프로토콜, 주기 등 파악</td>
        </tr>
        <tr>
          <td>아키텍처 구성</td>
          <td>계층별 구성과 상호 참조 도식화</td>
        </tr>
        <tr>
          <td>소프트웨어 구성</td>
          <td>사용중인 소프트웨어의 제품명, 용도, 라이선스 등</td>
        </tr>
        <tr>
          <td>하드웨어 구성</td>
          <td>사용중인 하드웨어의 제품명, 스펙, 수량 등</td>
        </tr>
        <tr>
          <td>네트워크 구성</td>
          <td>서버의 위치, 연결방식</td>
        </tr>
      </tbody>
    </table>
    <h3>기술 환경 파악</h3>
    <table class="last-td-left">
      <caption>개발 기술 환경 고려 사항</caption>
      <thead>
        <tr>
          <th>항목</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>운영체제<br>OS, Operating System</td>
          <td>
            고려사항: 가용성, 성능, 기술지원, 주변기기, 비용(TCO)<sup style="color:red">*</sup><br>
            Windows, UNIX, Linux, Mac OS, iOS, Android
          </td>
        </tr>
        <tr>
          <td>데이터베이스<br>DBMS, DataBase Management System</td>
          <td>
            가용성, 성능, 기술지원, 호환성, 비용(TCO)<br>
            Oracle, IBM DB2, Microsoft SQL Server, MySQL, SQLite, MongoDB, Redis
          </td>
        </tr>
        <tr>
          <td>웹 어플리케이션<br>WAS; Web Application Server</td>
          <td>
            가용성, 성능, 기술지원, 비용(TCO)<br>
            Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere
          </td>
        </tr>
      </tbody>
    </table>
    <ul style="font-size:0.9em">
      <li>TCO(Total Cost of Ownership): 구매, 라이선스, 유지보수, 에너지비용 등 모든 비용</li>
    </ul>

    <h2>요구사항 정의</h2>
    <p>
      고객(의뢰자, 사용자)가 본인이 원하는 바를 명확하게 모르거나, 정확한 용어(전문)로 기술하지 못 할 가능성이 있기 때문에 완성된 소프트웨어를 기준으로 어떠한 작업이 필요한지 명확히 하는 작업
    </p>
    <table class="last-td-left">
      <caption>요구사항 유형</caption>
      <thead>
        <tr>
          <th>유형</th>
          <th>내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>기능 요구사항<br>Functional requirements</td>
          <td>고객이 제공받고자 하는 주요 기능에 대한 사항</td>
        </tr>
        <tr>
          <td>비기능 요구사항<br>Non-functional requirements</td>
          <td>품질 관련 사항: 장비 구성, 처리속도, 인터페이스, 데이터 보안, 제도권 요구</td>
        </tr>
        <tr>
          <td>사용자 요구사항<br>User requirements</td>
          <td>사용자의 친숙도, 눈높이</td>
        </tr>
        <tr>
          <td>시스템 요구사항<br>System requirements</td>
          <td>개발자 관점</td>
        </tr>
      </tbody>
    </table>
    <h3>명세서 발행</h3>
    <p>
      도출(Elicitation) > 분석(Analysis) > 명세(Specification) > 확인(Validation)
    </p>

    <h2>요구사항 분석</h2>
    <p>
      구체적인 명세를 작성하여(문서화), 향후 유지보수에 활용한다.
    </p>
    <table class="last-td-left">
      <caption>분석기법</caption>
      <thead>
        <tr>
          <th>기법명</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>DFD<br>Data-flow diagram<br>자료 흐름도<br><sup>*</sup>버블(Bubble)차트</td>
          <td>객체간 데이터 이동을 표시
            <div class="img-box">
              <img
                src="//upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Data-flow-diagram-example.svg/478px-Data-flow-diagram-example.svg.png" />
              <span class="caption">자료흐름도 예시</span>
              <span class="description">"478px-Data-flow-diagram-example.svg.png", AutumnSnow, wikipedia.org, CC BY-SA
                3.0
              </span>
            </div>
            <table class="last-td-left">
              <caption>자료 흐름도 항목, ??표 안에 그림 넣을 것</caption>
              <thead>
                <tr>
                  <th>기호</th>
                  <th>표기</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>프로세스(Process)</td>
                  <td>원</td>
                </tr>
                <tr>
                  <td>자료 흐름(Data Flow)</td>
                  <td>화살표</td>
                </tr>
                <tr>
                  <td>자료 저장소(data Store)</td>
                  <td>위/아래 경계</td>
                </tr>
                <tr>
                  <td>단말(Terminator)</td>
                  <td>사각</td>
                </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>DD<br>Data Dictionary<br>자료 사전</td>
          <td>메타 데이터: 데이터의 내용 설명
            <table class="last-td-left">
              <caption>자료 사전 세부항목</caption>
              <thead>
                <tr>
                  <th>기호</th>
                  <th>의미</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>=</td>
                  <td>~으로 이루어져 있다(is composed of)</td>
                </tr>
                <tr>
                  <td>+</td>
                  <td>그리고(and)</td>
                </tr>
                <tr>
                  <td>( )</td>
                  <td>생략 가능(optional)</td>
                </tr>
                <tr>
                  <td>[A | B]</td>
                  <td>또는(or)</td>
                </tr>
                <tr>
                  <td>{}</td>
                  <td>
                    반복
                    <ul style="margin:0">
                      <li>\(\{A\}_n\): A를 최소 n회 반복</li>
                      <li>\(\{A\}^n\): A를 최대 n회 반복</li>
                      <li>\(\{A\}_n^m\): A를 최소 n회 최대 m회 반복</li>
                    </ul>
                  </td>
                <tr>
                  <td>* *</td>
                  <td>주석(Comment)</td>
                </tr>
              </tbody>
            </table>
          </td>
        </tr>
        <tr>
          <td>UML<br>Unified Modeling Language</td>
          <td>
            <ul>
              <li>
                <b>사물(Things)</b>
                <ul>
                  <li>구조적(Structural) 사물: Class, Use Case, Component, Node</li>
                  <li>행동(Behavioral) 사물: Interaction, State Machine</li>
                  <li>그룹(Grouping) 사물: Package</li>
                  <li>주해(Annotation, 주석) 사물: Note(부가 설명)</li>
                </ul>
              </li>
              <li>
                <b>관계(Relationships)</b>
                <ul>
                  <li>연관(Association) 관계: 서로 관련이 있음(예: 교사와 학생)</li>
                  <li>집합(Aggregation) 관계: 묶여 있음(예: 1반과 1반학생)</li>
                  <li>포함(Composition) 관계: 포함 되어 있음(예: 컴퓨터와 CPU)</li>
                  <li>일반화(Generalization) 관계: 일반적 표현(예: 커피와 아메리카노)</li>
                  <li>의존(Dependency) 관계: 참고 사항(예: 책과 저자)</li>
                  <li>실체화(Realization) 관계: 가상 인터페이스 구현(예: 가상과 실제)</li>
                </ul>
              </li>
              <li>
                <b>다이어그램(Diagram)</b>
                <ul>
                  <li>
                    구조적(Structural) 다이어그램
                    <ul>
                      <li>클래스(Class) 다이어그램: 클래스간 관계를 도식화</li>
                      <li>객체(Object) 다이어그램: 사물(객체)간의 관계 도식화. 럼바우(Rumbaugh)분석</li>
                      <li>컴포넌트(Component) 다이어그램: 컴포넌트간 인터페이스 도식화</li>
                      <li>배치(Deployment) 다이어그램: 물리적 요소의 위치 표현</li>
                      <li>복합체 구조(Coposite Structure) 다이어그램: 클래스나 컴포넌트의 내부 구조 표현</li>
                      <li>패키지(Package) 다이어그램: 그룹회된 패키지들간의 관계를 표현</li>
                    </ul>
                  </li>
                  <li>
                    행위(Behavioral) 다이어그램 ← 동적(시간)
                    <ul>
                      <li>유스케이스(Use Case Diagram) 다이어그램: 사용자(Actor)와 사례(Use Case)로 구성</li>
                      <li>순차(Sequence) 다이어그램: 객체간 주고받는 메시지를 순서대로 표시</li>
                      <li>커뮤니케이션(Communication) 다이어그램: 순차 다이어그램 + 객체간 연관성</li>
                      <li>상태(State) 다이어그램: 이벤트(event)에 의한 모드(mode)변환 시나리오를 제공, 럼바우(Rumbaugh)분석</li>
                      <li>활동(Activity) 다이어그램: 로직 조건에 관한 처리 흐름을 보여줌. ??순서도</li>
                      <li>상호작용 개요(Interaction Overview) 다이어그램: 상호작용 다이어그램 간의 흐름 표시</li>
                      <li>타이밍(Timing) 다이어그램: 객체 상태 변화와 시간 제약을 명시적으로 표현</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
            ※ 추가정보
            <ul>
              <li>스테레오 타입 객체를 표현할 때 길러멧<var>&lt;&lt; &nbsp;>></var>을 사용</li>
              <li>개발언어에 구애받지 않고, 비개발자도 (어느정도) 알아 볼 수 있도록 기호와 도형으로 표현</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>

    <style>
      .diagram-detail ul {
        margin: 0;
        padding-left: 1em;
      }
    </style>
    <table class="last-td-left diagram-detail">
      <caption>다이어그램 상세</caption>
      <thead>
        <tr>
          <th>다이어그램</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Use Case</td>
          <td>
            <ul>
              <li>사용자 관점(view)에서 상황별 시나리오(use case)를 제공</li>
              <li>구성 요소: System/System Scope, Actor(나, 외부, system:타시스템), Use Case, Relationships</li>
              <li>기존의 use case와 관계: 포함(include) / 확장(extend:특별 조건) / 연관(??) / 일반화(??)</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>Class Diagram</td>
          <td>
            <ul>
              <li>객체(class)의 속성, 함수 등의 정보를 표현</li>
              <li>구성 요소: class, relationship, operation(함수, 인터페이스), constraints(제약 조건)</li>
              <li>접근제어자: public(+), private(-), protected(#), package(~)</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>Sequence Diagram</td>
          <td>
            <ul>
              <li>객체간 주고받는 메시지를 시간(세로) 순서대로 표시</li>
              <li>구성 요소: actor, object, lifeline, active box, message, replay(return message), loop</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <p>
      기타 용어: Mini-Spec.(소단위 명세서), ERD(계체 관계도) STD(상태 전이도), 제어 명세서
    </p>

    <h3>분석 자동화 도구, CASE</h3>
    <table class="last-td-left">
      <caption>분석도구</caption>
      <thead>
        <tr>
          <th>도구명</th>
          <th>특징</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>SADT(Structured Analysis and Design Technique)</td>
          <td>SoftTech분석 도구</td>
        </tr>
        <tr>
          <td>SREM(Software Requirements Engineering Methodolgy)</td>
          <td>TRW사, RSL(Requirement Statement Language), REVS(Requirement Engineering and Validation System)</td>
        </tr>
        <tr>
          <td>PSL/PSA</td>
          <td>미시간 대학, PSL(Problem Statement Language), PSA(Problem Statement Analyzer)</td>
        </tr>
        <tr>
          <td>TAGS(Technology for Automated Generation of Systems)</td>
          <td>IORL(요구사항 명세 언어)</td>
        </tr>
      </tbody>
    </table>

    <h3>HIPO(Hierarchy Input Process Output)</h3>
    <ul>
      <li>프로젝트의 이해를 돕기 위해, 기능과 자료의 의존관계를 하향식으로 문서화하는 도구/방법</li>
    </ul>
    <table class="last-td-left">
      <caption>HIPO Chart의 종류</caption>
      <thead>
        <tr>
          <th>종류</th>
          <th>영문</th>
          <th>내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>가시적 도표</td>
          <td>Visual Table of Contents</td>
          <td>도식 목차</td>
        </tr>
        <tr>
          <td>총체적 도표</td>
          <td>Overview Diagram</td>
          <td>총괄 도표, 개요 도표, (입력, 처리, 출력)</td>
        </tr>
        <tr>
          <td>세부적 도표</td>
          <td>Detail Diagram</td>
          <td>상세 도표</td>
        </tr>
    </table>

    <h1>화면 설계</h1>
    <h2>사용자 인터페이스</h2>

    <span class="list-title">UI(User Interface) 특징</span>
    <ul>
      <li>빈번한 변경</li>
      <li>편리성, 가독성 -> 업무 효율, 이해도</li>
      <li>원칙: 직관성, 유효성(목적 명확, 명령 명확), 학습성(기시감), 유연성(사용자 중심)</li>
      <li>지침: 사용자 중심, 사용성(편리), 일관성, 단순성, 결과 예측 가능, 가시성, 심미성(디자인), 표준화, 접근성(연령, 장애), 명확성(인지, 쉬운 이해), 오류 발생 해결(사용자 오류 인식)
      </li>
      <li>인터페이스 기능(지원): 입력값 검증, 에러 처리 및 에러 출력, 도움 및 프롬프트(Prompt; 명령어 예시, 막연함X) 제공</li>
    </ul>

    <span class="list-title">Interface 종류</span>
    <ul>
      <li>CLI(Command Line Interface): 텍스트 입력, 텍스트 출력</li>
      <li>GUI(Graphical User Interface): 마우스 입력, 그래픽 화면 출력</li>
      <li>NUI(Natural User Interface): 음성, 행동 입력, 그래픽 화면 출력</li>
      <li>VUI(Voice User Interface): (특히) 음성 입력</li>
      <li>OUI(Organic User Interface): (특히) 하드웨어 분야에서, 사물 인터넷. 확장된 입력</li>
    </ul>
    <table class="all-td-left">
      <caption>모바일 입력</caption>
      <thead>
        <tr>
          <th>명령</th>
          <th>동작</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Tap</td>
          <td>누르기(터치)</td>
        </tr>
        <tr>
          <td>Double Tap</td>
          <td>두번 누르기(터치)</td>
        </tr>
        <tr>
          <td>Drag</td>
          <td>누른 채 이동(방향감지)</td>
        </tr>
        <tr>
          <td>Pan(Panning)</td>
          <td>누른 채 이동(경로감지)</td>
        </tr>
        <tr>
          <td>Press</td>
          <td>오래 누르기</td>
        </tr>
        <tr>
          <td>Flick</td>
          <td>빠른 스크롤(수평, 수직)</td>
        </tr>
        <tr>
          <td>Pinch</td>
          <td>두 손가락 확대/축소</td>
        </tr>
      </tbody>
    </table>

    <span class="list-title">도구(방법)</span>
    <ul>
      <li>와이어프레임(WireFrame): 페이지에 대한 개략적인 레이아웃, 손그림, ppt, keynote, 스케치, 일러스트, photoshop...</li>
      <li>목업(Mockup): 시각적으로만 구현(실제와 비슷), 파워 목업, 발사믹 목업...</li>
      <li>스토리보드(Story Board): 와이어프레임 + 페이지간 이동 + 설명(Description)</li>
      <li>프로토타입(Prototype): 그래픽 + 기능구현</li>
      <li>유스케이스(Use Case): 사용자 시나리오 상세 기술</li>
    </ul>

    <h3>UI요소</h3>
    <table class="last-td-left">
      <caption>UI요소</caption>
      <thead>
        <tr>
          <th>요소명</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Button</td>
          <td>눌렸을 때, 특정 기능을 수행하기위한 그래픽 인터페이스</td>
        </tr>
        <tr>
          <td>Check Box</td>
          <td>1개 이상의 선택(on/off)가 가능한 상자</td>
        </tr>
        <tr>
          <td>Radio Button</td>
          <td>2개 이상의 선택중 하나만 선택 가능한 버튼</td>
        </tr>
        <tr>
          <td>Text Box</td>
          <td>사용자의 타이핑 정보를 입력할 수 있는 상자</td>
        </tr>
        <tr>
          <td>Combo Box</td>
          <td>선택가능한 목록을 드롭다운으로 제공하고, 목록을 열어 선택이 가능</td>
        </tr>
        <tr>
          <td>List Box</td>
          <td>선택 가능한 목록을 펼쳐서 보여줌</td>
        </tr>
    </table>

    <span class="list-title">UI 시나리오</span>
    <ul>
      <li>UI 설계자 or interaction designer: UI 시나리오 문서 작성 > 개발자, 그래픽 디자이너, 검수자에 활용</li>
      <li>원칙: 구체적으로(추상적 표현X), 공통규칙 제시(일관성), 화면속 기능/흐름 정의, 변경 사항 기재(추적 용이성)</li>
      <li>템플릿(Template): 기본적인 레이아웃 형태</li>
    </ul>

    <span class="list-title">감성 공학</span>
    <ul>
      <li>HCI(Human Computer Interaction(Interface)): 사람의 편의성에 대해 연구</li>
      <li>UX(User Experience): 주관성(Subjectivity, 개인마다 다름), 정확성(Contextuality, 환경의 영향 받음), 총체성(Holistic, 감성적 최종 결과)</li>
      <li>컴퓨터가 소리/밝기 등을 정확하게 1, 2, 3출력했어도(정량평가) 사용자가 느끼기에 1, 3, 7로 느낀다면(정성평가) 사용자 느낌에 맞게 수정</li>
    </ul>

    <h2>품질 기준</h2>
    <table class="last-td-left">
      <caption>ISO/IEC 9126</caption>
      <thead>
        <tr>
          <th>항목</th>
          <th>분야</th>
          <th>내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>기능성(Functionality)</td>
          <td>기초</td>
          <td>적절성/적합성(Suitability), 정밀성/정확성(Accuracy), 상호 운용성(Interoperability), 보안성(Security), 준수성(Compliance, 표준 준수)
          </td>
        </tr>
        <tr>
          <td>신뢰성(Reliability)</td>
          <td>고장</td>
          <td>성숙성(Maturity), 고장 허용성(Fault Tolerance, 결함 극복과 정상 수행 정도), 회복성(Recoverability, 데이터 복구)</td>
        </tr>
        <tr>
          <td>사용성(Userbility)</td>
          <td>고객</td>
          <td>이해성(Understandability, 사용자가 볼 때~), 학습성(Learnability), 운용성(Operability, 사용자가~), 친밀성(Attractiveness, 재사용 의지)
          </td>
        </tr>
        <tr>
          <td>효율성(Efficiency)</td>
          <td>성능</td>
          <td>시간 효율성(Time Behaviour), 자원 효율성(Resource Behaviour)</td>
        </tr>
        <tr>
          <td>유지 보수성(Maintainability)</td>
          <td>관리</td>
          <td>분석성(Analyzability, 결함 원인을), 변경성(Changeability, 수정 가능 정도), 안정성(Stability, 오류 파급 최소화), 시험성(Testability)</td>
        </tr>
        <tr>
          <td>이식성(Portability)</td>
          <td>호환</td>
          <td>적용성(Adaptability, 다른 분야에), 설치성(Installability, 다른 환경에), 대체성(Replaceability, 타SW 이식), 공존성(Co-existence,
            자원공유)</td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>ISO/IEC 12119: ISO/IEC 9126 + 테스트 절차</li>
      <li>ISO/IEC 14598: SW 품질 측정, 평가 절차 표준</li>
    </ul>

    <table class="last-td-left">
      <caption>ISO/IEC 25010</caption>
      <thead>
        <tr>
          <th>항목</th>
          <th>내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>기능 적합성</td>
          <td>기능 완전성, 기능 정확성, 기능 적절성</td>
        </tr>
        <tr>
          <td>성능 효율성</td>
          <td>시간 효율성, 자원 효율성, 사양</td>
        </tr>
        <tr>
          <td>호환성</td>
          <td>공존성, 상호운영성</td>
        </tr>
        <tr>
          <td>사용성</td>
          <td>적절 인지정도, 학습성, 조작성, 사용자 오류 방지, UI 미학, 접근성</td>
        </tr>
        <tr>
          <td>신뢰성</td>
          <td>성숙성, 사용가능성, 결함 허용성, 복구성</td>
        </tr>
        <tr>
          <td>보안성</td>
          <td>기밀성, 무결성, 부인방지, 책임추적성, 인증성</td>
        </tr>
        <tr>
          <td>유지 보수성</td>
          <td>모듈성, 재사용성, 분석성, 변경성, 시험성</td>
        </tr>
        <tr>
          <td>이식성</td>
          <td>적응성, 설치성, 대체성</td>
        </tr>
      </tbody>
    </table>

    <h1>애플리케이션 설계</h1>
    <h2>아키텍처 설계</h2>

    <table class="only-first-td-center">
      <caption>상위 설계 vs 하위 설계</caption>
      <thead>
        <tr>
          <th></th>
          <th>상위 설계</th>
          <th>하위 설계</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>별칭</td>
          <td>아키텍처 설계, 예비 설계</td>
          <td>모듈 설계, 상세 설계</td>
        </tr>
        <tr>
          <td>설계 대상</td>
          <td>시스템의 전체적인 구조</td>
          <td>시스템의 내부 구조 및 행위</td>
        </tr>
        <tr>
          <td>세부 목록</td>
          <td>구조, DB, 인터페이스(정의, 설계)</td>
          <td>컴포넌트, 자료 구조, 알고리즘</td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>모듈화(Modulatiry): 시스템의 내용을 기능단위로 분리하여 관리</li>
      <li>추상화(Abstraction): 포괄적/개념적 설계, ①과정 추상화 ②데이터 추상화 ③제어 추상화</li>
      <li>단계적 분해(Stepwise Refinement): 하향식 설계</li>
      <li>정보 은닉(Information Hiding): 내부 정보를 다른 모듈이 알아서도 안되고 알필요도 없도록 설계</li>
      <li>소프트웨어 아키텍처의 품질 속성 고려(표)</li>
    </ul>

    <table class="last-td-left">
      <caption>SW 품질 속성 고려항목</caption>
      <thead>
        <tr>
          <th>항목</th>
          <th>세부</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>시스템 측면</td>
          <td>성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성, 테스트 용이성, 배치성, 안정성</td>
        </tr>
        <tr>
          <td>비지니스 측면</td>
          <td>시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표시장, 공개 일정, 기존 시스템과 통합</td>
        </tr>
        <tr>
          <td>아키텍처 측면</td>
          <td>개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성, 적응성, 일치성, 대체성</td>
        </tr>
      </tbody>
    </table>

    <span class="list-title">SW 아키텍처 설계 과정</span>
    <ol>
      <li>설계 목표 설정</li>
      <li>
        시스템 타입 결정: System + Sub System Type 결정, 아키텍처의 패턴 결정
        <ul>
          <li>System Type: 대화형(쇼핑몰), 이벤트 중심(비상벨), 변환형(컴파일러, 라우터), 객체 영속형(관리SW)</li>
        </ul>
      </li>
      <li>아키텍처의 패턴 적용(지문: 스타일 적용 및 커스터마이즈)</li>
      <li>
        서브 시스템 구체화: 상호작용, 인터페이스 정의
        <ul>
          <li>
            협약(Contract)에 의한 설계
            <ul>
              <li>선행 조건(Precondition): 오퍼레이션 호출 전, 만족 조건</li>
              <li>불변 조건(Invariant): 오퍼레이션 수행 중, 항상 만족 조건</li>
              <li>결과 조건(Postcondition): 오퍼레이션 수행 후, 만족 조건</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>검토</li>
    </ol>

    <h2>패턴</h2>
    <table class="last-td-left">
      <caption>Pattern의 종류</caption>
      <thead>
        <tr>
          <th>패턴명</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Layers Pattern</td>
          <td>subsystem이 상하 계층 구조를 이룸(예:OSI 7계층)</td>
        </tr>
        <tr>
          <td>Client-Server Pattern</td>
          <td>하나의 Sever에 다수의 Client를 처리, Server는 항상 대기</td>
        </tr>
        <tr>
          <td>Pipe-Filter Pattern</td>
          <td>Data stream의 각 단계를 Filter Component로 Capsule화하여 이어붙임</td>
        </tr>
        <tr>
          <td>MVC(Model-View-Controller) Pattern</td>
          <td>Model(핵심 기능 및 데이터), View(보여지는 정보, 출력 처리기), Controller(입력 처리기)</td>
        </tr>
        <tr>
          <td>Master-Slave Pattern</td>
          <td>Fault Tolerance System(장애 허용 시스템; 일부 결함에도 전체기능 완수 도움), 병렬 시스템</td>
        </tr>
        <tr>
          <td>Broker Pattern</td>
          <td>분산 환경에서 각 서비스에 대한 컴포넌트 선택 수행</td>
        </tr>
        <tr>
          <td>Peer-To-Pear Pattern</td>
          <td>Multi Threading환경에서 각자 독립적으로 수행</td>
        </tr>
        <tr>
          <td>Event-Bus Pattern</td>
          <td>Source(이벤트 생성), Listener(수행), Channel(통로), Bus(채널 관리)</td>
        </tr>
        <tr>
          <td>Blackboard Pattern</td>
          <td>공유 데이터, 컴포넌트 접근을 관리</td>
        </tr>
        <tr>
          <td>Interpreter Pattern</td>
          <td>특정 언어로 작성된 코드를 해석하는 컴포넌트 설계</td>
        </tr>
      </tbody>
    </table>

    <h2>객체지향(Objecxt-Oriented)</h2>
    <p>
      SW로직을 실생활에서 물체를 인식하는 방식으로 작성하여(대상화) 제작과 관리의 이점을 갖는 기법.
    </p>
    <table class="last-td-left">
      <caption>객체지향 용어</caption>
      <thead>
        <tr>
          <th>용어</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Object(객체)</td>
          <td>
            하나의 모듈<br>
            구성: 식별자(이름), 데이터(Attribute, Variable, 상태), 함수(Method, Service, Operation, function)<br>
            message: 어떤 행위를 지시하는 명령
          </td>
        </tr>
        <tr>
          <td>Class</td>
          <td>
            각각의 객체를 정의한 구문. 하나 이상 유사한 객체가 묶일 수 있음.<br>
            Instance: 생성된 class. 같은 class에 속한 각각의 객체
          </td>
        </tr>
        <tr>
          <td>Encapsulation(캡슐화)</td>
          <td>보안 또는 단순화의 목적으로 데이터와 함수를 묶는 행위. Interface만 노출(=일부만 노출)</td>
        </tr>
        <tr>
          <td>Inheritance(상속)</td>
          <td>객체를 구현할 때, 부모의 특성을 물려받아 좀 더 간편하고 조직적으로 구성하는 행위</td>
        </tr>
        <tr>
          <td>Polymorphism(다형성)</td>
          <td>상속으로 이루어진 구조체에서 임의의 동작을 수행함에 있어 높은 자유도를 부과하는 기법</td>
        </tr>
        <tr>
          <td>Relationship(연관성)</td>
          <td>
            두 개 이상의 객체가 참조하는 관계
            <table class="last-td-left">
              <caption>연관성 종류</caption>
              <thead>
                <tr>
                  <th>종류</th>
                  <th>의미</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>is member of</td>
                  <td>Association(연관화)</td>
                </tr>
                <tr>
                  <td>is instance of</td>
                  <td>Classification(분류화)</td>
                </tr>
                <tr>
                  <td>is part of</td>
                  <td>Aggregation(집단화)</td>
                </tr>
                <tr>
                  <td rowspan="2">is a</td>
                  <td>Generalization(일반화)</td>
                </tr>
                <tr>
                  <td>spacialization(상세화)</td>
                </tr>
              </tbody>
            </table>
          </td>
        </tr>
    </table>

    <h3>객체지향 분석(OOA; Object Oriented Analysis)</h3>
    <ul>
      <li>
        럼바우(Runbaugh) 방법
        <ol style="margin-left:1.5em">
          <li>Object(객체) Modeling: 시스템에서 요구되는 객체를 찾아내서 속성과 연산 식별 및 객체들 간의 관계를 규정</li>
          <li>Dynamic(동적) Modeling: 상태 다이어그램을 이용하여 시간 흐름에 따른 제어 흐름 표현</li>
          <li>Function(기능) Modeling: 자료 흐름도(DFD)를 이용하여 프로세스 간의 자료이동을 표현</li>
        </ol>
      </li>
      <li>Booch(부치) 방법: 미시적, 거시적 모두 분석. 클래스 속성과 연산 정의</li>
      <li>Jacobson 방법: Use Case를 강조</li>
      <li>Coad-Yourdon 방법: E-R 다이어그램 사용, 객체, 구조, 주제, 속성, 인스턴스 연결 등 정의</li>
      <li>Wirfs-Brock 방법: 분석과 설계 간 구분X, 고객 명세서를 평가해서 설계까지 연속적 수행</li>
    </ul>

    <table class="last-td-left">
      <caption>SOLID원칙</caption>
      <thead>
        <tr>
          <th></th>
          <th>원칙</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>S</td>
          <td>SRP</td>
          <td>Single Responsibility Principle(단일 책임 원칙): 한 가지 목표(높은 응집, 낮은 결합)</td>
        </tr>
        <tr>
          <td>O</td>
          <td>OCP</td>
          <td>Open Closed Principle(개방 폐쇄 원칙): 개방(기능 추가에 자유롭다), 폐쇄(변경에 보수적)</td>
        </tr>
        <tr>
          <td>L</td>
          <td>LSP</td>
          <td>Liskov Substitution Principle(리스코프 치환 원칙): 자식 클래스가 부모 클래스의 기능을 무시/재정의 하는 것을 우려</td>
        </tr>
        <tr>
          <td>I</td>
          <td>ISP</td>
          <td>Interface Segregation Principle(인터페이스 분리 원칙): 사용하지 않는 인터페이스에 의존X, 1목적 1인터페이스</td>
        </tr>
        <tr>
          <td>D</td>
          <td>DIP</td>
          <td>Dependency Inversion Principle(의존 역전 원칙): 추상성이 높은 클래스와 의존관계를 맺는다</td>
        </tr>
    </table>

    <h2>결합도 vs 응집도</h2>
    <p>
      모듈의 재사용성을 늘리려면,
    </p>
    <ul>
      <li>결합도: 타모듈과의 통신에서 독립적이 높아야(의존성이 적어야) 다른데 또 써먹기가 좋음. 인터페이스의 자유도↑</li>
      <li>응집도: 내부의 모듈간이 수정이나 도움 없이 하나의 목적을 완벽히 수행해야 좋음.</li>
    </ul>
    <table class="last-td-left">
      <caption>결합도(Coupling)</caption>
      <tbody>
        <tr>
          <td rowspan="6">
            낮음<br>
            (좋음)<br>
            ↑<br>
            <br>
            ↓<br>
            (나쁨)<br>
            높음
          </td>
          <td>Data Coupling</td>
          <td>자료 결합도</td>
          <td>모듈 간 인터페이스가 기본자료로만 구성될 때</td>
        </tr>
        <tr>
          <td>Stamp Coupling</td>
          <td>스탬프(검인) 결합도</td>
          <td>배열, 레코드 등으로 구성 될 때</td>
        </tr>
        <tr>
          <td>Control Coupling</td>
          <td>제어 결합도</td>
          <td>제어신호(약속된 코드)를 사용할 때</td>
        </tr>
        <tr>
          <td>External Coupling</td>
          <td>외부 결합도</td>
          <td>다른 모듈의 자료를 참조해야 할 때</td>
        </tr>
        <tr>
          <td>Common Coupling</td>
          <td>공통(공유) 결합도</td>
          <td>데이터 저장위치가 강제될 때(공유장소)</td>
        </tr>
        <tr>
          <td>Content Coupling</td>
          <td>내용 결합도</td>
          <td>직접 가지러 가야 할 때(어디에, 무엇이, 어떻게를 다 알아야...)</td>
        </tr>
      </tbody>
    </table>

    <table class="last-td-left">
      <caption>응집도(Cohesion)</caption>
      <tbody>
        <tr>
          <td rowspan="7">
            낮음<br>
            (나쁨)<br>
            ↑<br>
            <br>
            ↓<br>
            (좋음)<br>
            높음
          </td>
          <td>Coincidental Cohesion</td>
          <td>우연적 응집도</td>
          <td>각 구성요소의 연관성이 거의 없다시피</td>
        </tr>
        <tr>
          <td>Logical Cohension</td>
          <td>논리적 응집도</td>
          <td>유사한 성격의 요소들이 관찰됨</td>
        </tr>
        <tr>
          <td>Temporal Cohension</td>
          <td>시간적 응집도</td>
          <td>특정 시간에 처리되는 몇개의 기능들이 모임</td>
        </tr>
        <tr>
          <td>Procedual Cohension</td>
          <td>절차적 응집도</td>
          <td>다수 관련 기능을 가지고, 순차적으로 수행</td>
        </tr>
        <tr>
          <td>Communication Cohension</td>
          <td>교환(통신)적 응집도</td>
          <td>동일한 입력과 출력을 사용하여 서로 다른 기능을 수행</td>
        </tr>
        <tr>
          <td>Sequential Cohension</td>
          <td>순차적 응집도</td>
          <td>하나의 입력으로 나온 출력 데이터가 다음 입력으로 사용</td>
        </tr>
        <tr>
          <td>Functional Cohension</td>
          <td>기능적 응집도</td>
          <td>단일 문제와 연관되어 수행될 경우의 응집도</td>
        </tr>
      </tbody>
    </table>

    <h3>Fan-In, Fan-Out</h3>
    <ul>
      <li>Fan-In:입력, Fan-Out:출력</li>
      <li>인터페이스가 많아지면, 시스템 복잡도↑</li>
    </ul>

    <h3>N-S(Nossi-Schneidermon) chart</h3>
    <div class="img-box">
      <img src="https://static.blex.me/images/content/2021/3/28/13_vN7Nc92jr7d9PXROxXfT.png" />
      <span class="caption">NS chart 예시</span>
      <span class="description">blex.me/@mildsalmon/필기-공부-소프트웨어-공학#1-모델링-언어</span>
    </div>
    <ul>
      <li>순서도를 화살표 없이 표로 작성</li>
    </ul>

    <h2>SW 재사용</h2>
    <span class="list-title">공통모듈: 범용으로 사용하기 위해 제작하는 모듈</span>
    <ul>
      <li>Correctness(정확성): ??</li>
      <li>Clearity(명확성): 중의적 해석x</li>
      <li>Completeness(완전성): ??</li>
      <li>Consistency(일관성): ??충돌방지</li>
      <li>Traceability(추적성): ??</li>
    </ul>

    <span class="list-title">재사용(Reuse): 이미 개발한 모듈의 활용</span>
    <ul>
      <li>함수와 객체 재사용</li>
      <li>컴포넌트 재사용</li>
      <li>애플리케이션 재사용</li>
    </ul>
    <p>
      컴포넌트: 인터페이스로만 접근할 수 있는 단위
    </p>

    <h2>코드</h2>
    <p>
      코드는 식별, 분류, 배열, 표준, 간소 기능을 만족하고, 어느정도 체계를 권장(무작위x)
    </p>
    <table class="last-td-left">
      <caption>코드의 종류</caption>
      <tbody>
        <tr>
          <td>Sequence Code</td>
          <td>순차코드</td>
          <td>1, 2, 3, 4...</td>
        </tr>
        <tr>
          <td>Block Code</td>
          <td>블럭코드</td>
          <td>1001~1099: 보병, 1700~1799: 통신병</td>
        </tr>
        <tr>
          <td>Decimal code</td>
          <td>10진 코드</td>
          <td>1000: SW설계(각 자리수가 각각의 분류를 의미)</td>
        </tr>
        <tr>
          <td>Group Classification Code</td>
          <td>그룹 분류 코드</td>
          <td>본사-총무부-인사계</td>
        </tr>
        <tr>
          <td>Mnemonic Code</td>
          <td>연상 코드</td>
          <td>TV-40: 40인치 TV</td>
        </tr>
        <tr>
          <td>Significant Digit Code</td>
          <td>표의 숫자 코드</td>
          <td>120-720-1500: 120x720x1500의 강판(물리적 수치)</td>
        </tr>
        <tr>
          <td>Combined Code</td>
          <td>합성코드</td>
          <td>KR-123: 한국국적기 123</td>
        </tr>
    </table>

    <h2>패턴</h2>
    <table class="last-td-left">
      <caption>패턴의 종류</caption>
      <thead>
        <tr>
          <th>범주</th>
          <th>패턴 명</th>
          <th>내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td rowspan="5">Creational Pattern<br>생성패턴</td>
          <td>Abstract Factory</td>
          <td>??: 인터페이스를 통해 서로 연관 의존하는 객체 그룹을 생성</td>
        </tr>
        <tr>
          <td>Builder</td>
          <td>동일한 객체 생성에도 서로 다른 결과를 만들어 낼 수 있도록</td>
        </tr>
        <tr>
          <td>Factory Method</td>
          <td>=가상 생성자(Virtual Constructor) 패턴, 객체를 생성하기 위한 인터페이스를 정의하여 어떤 클래스가 인스턴스화 될 것인지는 서브 클래스가 결정하도록 하는 것</td>
        </tr>
        <tr>
          <td>Prototype</td>
          <td>Prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조</td>
        </tr>
        <tr>
          <td>Singleton</td>
          <td>인스턴스가 하나임을 보장하여 불필요한 메모리 낭비를 최소화, 동시참조X</td>
        </tr>
        <tr>
          <td rowspan="7">Structural Pattern<br>구조 패턴</td>
          <td>Adapter</td>
          <td>호환성이 없는 어댑터를 호환성을 부여하기 위한 패턴</td>
        </tr>
        <tr>
          <td>Bridge</td>
          <td>기능과 구현의 클래스로 구현하여 각각 독립적으로 확장하기 위한 패턴</td>
        </tr>
        <tr>
          <td>Composite</td>
          <td>단일 객체와 복합 객체의 구분 없이 사용하고자 할 때</td>
        </tr>
        <tr>
          <td>Decorator</td>
          <td>임의 객체에 부가 기능을 추가하기 위해</td>
        </tr>
        <tr>
          <td>Facade(퍼싸드)</td>
          <td>sub class를 통합하는 객체</td>
        </tr>
        <tr>
          <td>Flyweight</td>
          <td>인스턴스 필요시 생성하지 않고, 공유 사용</td>
        </tr>
        <tr>
          <td>Proxy</td>
          <td>접근이 어려운 객체 사이에 인터페이스 역할</td>
        </tr>
        <tr>
          <td rowspan="11">Behavioral Pattern<br>행위 패턴</td>
          <td>Chain of Responsibility</td>
          <td>요청을 처리할 수 있는 여러개의 객체를 묶어 해결될때까지 돌려가며 사용</td>
        </tr>
        <tr>
          <td>Command</td>
          <td>요청을 로그화하여 처리</td>
        </tr>
        <tr>
          <td>Interpreter</td>
          <td>SQL, 통신 프로토콜 같은 명령어 해석기</td>
        </tr>
        <tr>
          <td>Iterator</td>
          <td>접근이 잦은 개체를 반복적으로 접근하기 위한 구조</td>
        </tr>
        <tr>
          <td>Mediator</td>
          <td>중재자: 객체간의 상호작용(통제, 지시)을 캡슐화하여 전달하는 구조</td>
        </tr>
        <tr>
          <td>Memento</td>
          <td>특정 상태를 객체화하여 되돌리기에 적합한 구조</td>
        </tr>
        <tr>
          <td>Observer</td>
          <td>특정 객체의 변화를 감지하여 다른 객체에 전달하는 구조</td>
        </tr>
        <tr>
          <td>State</td>
          <td>객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때, 상태를 캡슐화</td>
        </tr>
        <tr>
          <td>Strategy</td>
          <td>동일한 계열의 알고리즘을 개별적으로 캡슐화하여 서로 교환</td>
        </tr>
        <tr>
          <td>Template Method</td>
          <td>상위 클래스에서 Template(Algorithm)을 정의하고, 서브클래스에서 이외의 내용 정의</td>
        </tr>
        <tr>
          <td>Visitor</td>
          <td>처리기능을 별도의 클래스로 분리하여, 각 객체가 해당처리를 위해 특정 객체에 방문하는 구조</td>
        </tr>
      </tbody>
    </table>

    <h1>인터페이스 분석</h1>
    <ul>
      <li>인터페이스 분석 요소: 이름, 연계(연관) 시스템, 내용 및 범위, 방식(프로토콜), 주기, 고려사항, 우선순위</li>
      <li>기능/비기능으로 분류</li>
      <li>이미 정의된 인터페이스도 분해될 수 있다</li>
      <li>절차: 선별 > 자료준비 > 분류 > 분석 및 구체화 > 배포(공유)</li>
    </ul>

    <h2>요구사항 검증</h2>
    <ol>
      <li>
        Requirements Verification(검증)
        <ul>
          <li>계획 > 검토 및 수정 > 베이스라인 설정</li>
        </ul>
      </li>
      <li>
        계획
        <ul>
          <li>기준 및 방법 제시</li>
          <li>참여자 모집</li>
          <li>체크리스트 작성</li>
          <li>관련 자료 수집</li>
          <li>일정 수립</li>
        </ul>
      </li>
      <li>
        검토 및 수정
        <ul>
          <li>방법: Peer Review(회의), Walk Through(자료배포, 회의 짧게), Inspection(전문검토 그룹)</li>
          <li>Prototyping, Test Cast(TC)설계, CASE(Computer Aided Software Engineering) 도구 활용</li>
          <li>검증 항목: Completeness(완전성), Consistency(일관성), Unambiguity(명확성), Functionality(기능성), Verifiability(검증 가능성), Traceability(추적 가능성), Easily Changeable(변경 용이성)</li>
        </ul>
      </li>
      <li>
        분류
        <ul>
          <li>시스템간 연계:  DB Link, API/Open API, EAI(Enterprise Application Intergration; 송수신 통제 시스템)이용, Socket, Web Service</li>
          <li>연계 메커니즘: 송신 시스템(파일로 전송), 수신 시스템(파일 처리), 연계 서버(모니터링)</li>
          <li>통신 유형: 단방향/양방향, 동기/비동기</li>
          <li>처리 유형: 실시간/지연 처리, 배치(대량)</li>
        </ul>
      </li>
    </ol>

    <h2>미들웨어</h2>
    <ul>
      <li>정의: 분산 컴퓨팅 환경에서 이용자가 전체 메커니즘을 이해하지 못해도 이기종간 원만한 통신을 중재하는 SW</li>
      <li>위치 투명성(Location Transparency)제공</li>
      <li>재사용 가능한 서비스 구현</li>
      <li>중재: 앱-사용자, 서버-클라이언트</li>
      <li>
        종류
        <ul>
          <li>RPC(Remote Procedure Call, 원격 프로시저 호출): 원격 프로시저를 마치 로컬 프로시저처럼 호출 가능하게 하는 SW</li>
          <li>DB(DataBase): 원격DB의 조회/조작을 제공</li>
          <li>MOM(Message Oriented Middleware): 메시지기반 비동기형 전달방식(IBM-MQ, Oracle-Message Q, JCP-JMS), 느리지만 안정적</li>
          <li>TP-Monitor(Transaction Processing Monitor, 트렌젝션 관리): 각종 온라인 예약 업무 등</li>
          <li>ORB(Object Request Broker, 객체 요청 브로커): 미들웨어 CORBA(Common Object Request Broker Architecture, 코바, 분산 객체 관리 표준)</li>
          <li>WAS(Web Application Server): HTTP기반 서버/클라이언트 환경, Web Server(x), 동적 컨텐츠 처리</li>
        </ul>
      </li>
    </ul>
  </article>
</body>

</html>